import datetime
import time
from abc import ABCMeta, abstractmethod, abstractproperty
from copy import deepcopy
from src.core.parameter import Parameter
from src.core.instruments import Instrument
from PyQt4 import QtCore
from collections import deque
import os
import pandas as pd
import glob
import json as json
from PySide.QtCore import Signal, QThread
from src.core.read_write_functions import save_b26_file
import numpy as np
from __builtin__ import len as builtin_len
from matplotlib.backends.backend_pdf import FigureCanvasPdf as FigureCanvas # use this to avoid error that plotting should only be done on main thread
from matplotlib.figure import Figure

# cPickle module implements the same algorithm as pickle, in C instead of Python.
# It is many times faster than the Python implementation, but does not allow the user to subclass from Pickle.
import cPickle

class Script(object):
    # __metaclass__ = ABCMeta

    # ========================================================================================
    # ======= Following old_functions have to be customized for each instrument subclass =========
    # ========================================================================================

    # '''
    # returns the default settings of the script
    # settings contain Parameters, Instruments and Scripts
    # :return:
    # '''
    # _DEFAULT_SETTINGS = Parameter([
    #     Parameter('parameter', 1),
    #     Parameter('file_path', './some/path')
    # ])
    #

    # ========================================================================================
    # ======= Following old_functions are generic ================================================
    # ========================================================================================

    def __init__(self, name = None, settings = None, instruments = None, scripts = None, log_function = None, data_path = None):
        """
        executes scripts and stores script parameters and settings
        Args:
            name (optinal):  name of script, if not provided take name of function
            settings (optinal): a Parameter object that contains all the information needed in the script
            instruments (optinal): instruments used in the script
            scripts (optinal):  sub_scripts used in the script
            log_function(optinal): function reference that takes a string
        """

        self._script_class = self.__class__.__name__

        if name is None:
            name = self.__class__.__name__
        self.name = name

        self._instruments = {}
        if instruments is None:
            instruments = {}
        else:
            assert isinstance(instruments, dict)
            assert set(self._INSTRUMENTS.keys()) <= set(instruments.keys())

        self.data_path = data_path

        self.instruments = {key: instruments[key] for key in self._INSTRUMENTS.keys()}

        self._scripts = {}
        if scripts is None:
            scripts = {}
        self.scripts = scripts

        # set end time to be before start time if script hasn't been excecuted this tells us
        self.start_time = datetime.datetime.now()
        self.end_time = self.start_time - datetime.timedelta(seconds=1)

        self._settings = deepcopy(self._DEFAULT_SETTINGS)

        if settings is not None:
            self.update(settings)
        self._abort = False
        # data hold the data generated by the script,
        # this should either be a dictionary or a deque of dictionaries
        self.data = {}

        # a log for status outputs
        self.log_data = deque()
        # this can be overwritten
        self.log_function = log_function

        # default value is 'none', overwrite this in script if it has plotting capabilities
        self._plot_type = 'none'

    @property
    def data_path(self):
        return self._data_path
    @data_path.setter
    def data_path(self, path):
        # check is path is a valid path string
        if path is not None:
            assert os.path.isabs(path)
        self._data_path = path


    # @abstractmethod
    def _function(self):
        """
        This is the actual function that will be executed. It uses only information that is provided in the settings property
        will be overwritten in the __init__
        """
        # some generic function
        raise NotImplementedError

    def log(self, string):
        """
        appends input string to log file and sends it to log function (self.log_function)
        Returns:

        """

        self.log_data.append(string)
        if self.log_function is None:
            print(string)
        else:
            self.log_function(string)

    @property
    def _DEFAULT_SETTINGS(self):
        """
        returns the default parameter_list of the script this function should be over written in any subclass
        """
        raise NotImplementedError("Subclass did not implement _DEFAULT_SETTINGS")
    @property
    def _INSTRUMENTS(self):
        """

        Returns: a dictionary of the instruments, where key is the instrument name and value is the instrument class
        if there is not instrument it should return an empty dict

        """
        raise NotImplementedError("Subclass did not implement _INSTRUMENTS")
    @property
    def _SCRIPTS(self):
        """

        Returns: a dictionary of the instruments, were key is the instrument name and value is the instrument class
        if there is not instrument it should return an empty dict

        """
        raise NotImplementedError("Subclass did not implement _SCRIPTS")

    def __str__(self):

        output_string = '{:s} (class type: {:s})\n'.format(self.name, self.__class__.__name__)

        output_string += 'settings:\n'
        for key, value in self.settings.iteritems():
            output_string += "{:s} : {:s}\n".format(key, str(value))
        return output_string
    @property
    def name(self):
        return self._name
    @name.setter
    def name(self, value):
        if isinstance(value, unicode):
            value = str(value)

        assert isinstance(value, str), str(value) + ' is not a string'
        self._name = value

    @property
    def instrumets(self):
        return self._instruments
    @instrumets.setter
    def instruments(self, instrument_dict):
        assert isinstance(instrument_dict, dict)
        assert set(self._INSTRUMENTS.keys()) <= set(instrument_dict.keys()), "keys in{:s}\nkeys expected{:s}".format(str(instrument_dict.keys()), str( self._INSTRUMENTS.keys()))
        for key, value in self._INSTRUMENTS.iteritems():
            self._instruments.update({key: instrument_dict[key]})

    @property
    def plot_type(self):
        """
        overwrite this function if script has plotting abilities
        Returns: the type of plot the script produces
            'none' - no plot (script doesn't produce any plottable data)
            'main' - single plot on main plot
            'aux' -  single plot on auxilary plot
            'two' -  two plots, typically a main plot and a small plot that shows some intermediate data

        """

        return self._plot_type

    @property
    def scripts(self):
        return self._scripts
    @scripts.setter
    def scripts(self, script_dict):
        assert isinstance(script_dict, dict)
        assert script_dict.keys() == self._SCRIPTS.keys(), "keys in{:s}\nkeys expected{:s}".format(str(script_dict.keys()), str( self._SCRIPTS.keys()))

        for key, value in self._SCRIPTS.iteritems():
            assert isinstance(script_dict[key], self._SCRIPTS[key])
            self._scripts.update({key: script_dict[key]})

    @property
    def settings(self):
        '''
        :return: returns the settings of the script
        settings contain Parameters, Instruments and Scripts
        '''
        return self._settings

    def update(self, settings):
        '''
        updates the internal dictionary
        Args:
            settings: parameters to be set
        # mabe in the future:
        # Returns: boolean that is true if update successful

        '''
        if 'settings' in settings:
            self._settings.update(settings['settings'])
        else:
            self._settings.update(settings)

        if 'instruments' in settings:
            for instrument_name, instrument_setting in settings['instruments'].iteritems():
                self.instruments[instrument_name].update(instrument_setting)

    @property
    def end_time(self):
        '''
        time when script execution started
        :return:
        '''
        return self._time_stop
    @end_time.setter
    def end_time(self, value):
        assert isinstance(value, datetime.datetime)
        self._time_stop = value

    @property
    def start_time(self):
        '''
        time when script execution started
        :return:
        '''
        return self._time_start
    @start_time.setter
    def start_time(self, value):
        assert isinstance(value, datetime.datetime)
        self._time_start = value

    @property
    def excecution_time(self):
        '''
        :return: script excecition time as time_delta object to get time in seconds use .total_seconds()
        '''
        return self.end_time - self.start_time

    def run(self):
        '''
        executes the script
        :return: boolean if execution of script finished succesfully
        '''
        self.is_running = True
        self.log_data.clear()
        self.start_time  = datetime.datetime.now()
        self.log('starting script {:s} at {:s} on {:s}'.format(self.name, self.start_time.strftime('%H:%M:%S'),self.start_time.strftime('%d/%m/%y')))
        self._function()

        self.end_time  = datetime.datetime.now()
        self.log('script {:s} finished at {:s} on {:s}'.format(self.name, self.end_time.strftime('%H:%M:%S'),self.end_time.strftime('%d/%m/%y')))
        success = self._abort == False
        self.is_running = False
        return success

    def stop(self):
        self._abort == True

    def filename(self, appendix = None):
        """
        creates a filename based
        Args:
            appendix: appendix for file

        Returns: filename

        """

        # if provided path is a relative path and self.data_path exists, build path
        if os.path.isabs(self.settings['path']) == False and self.data_path is not None:
            path = os.path.join(self.data_path, self.settings['path'])
        else:
            path = self.settings['path']

        tag = self.settings['tag']

        filename = os.path.join(path, "{:s}_{:s}".format(self.start_time.strftime('%y%m%d-%H_%M_%S'),tag))

        if os.path.exists(filename) == False:
            os.makedirs(filename)

        if appendix is not None:
            filename = os.path.join(filename,  "{:s}_{:s}{:s}".format(self.start_time.strftime('%y%m%d-%H_%M_%S'),tag,appendix))

        return filename
    def to_dict(self):
        """

        Returns: itself as a dictionary

        """

        dictator = {self.name: {'class' : self.__class__.__name__}}

        if self.scripts != {}:
            dictator[self.name].update({'scripts': {} })
            for subscript_name, subscript in self.scripts.iteritems():
                dictator[self.name]['scripts'].update(subscript.to_dict() )

        if self.instruments != {}:
            # dictator[self.name].update({'instruments': self.instruments})
            # dictator[self.name].update({'instruments': {} })
            # for instrument_name, instrument in self.instruments.iteritems():
            #     dictator[self.name]['instruments'].update(instrument.to_dict())

            dictator[self.name].update({'instruments': {
                instrument_name: {'class': instrument['instance'].__class__.__name__, 'settings':instrument['settings']}
                for instrument_name, instrument in self.instruments.iteritems()
            }})

        dictator[self.name]['settings'] = self.settings

        return dictator
    def save_data(self, filename = None):
        """
        saves the script data to a file: filename is filename is not provided, it is created from internal function

        Returns:

        """


        def len(x):
            """
            overwrite the buildin len function to cover cases that don't have a length, like int or float
            and to catch string as objects of length 0
            Args:
                x: quantity of which we want to find the length
            Returns: length of x

            """
            if isinstance(x, (int, float, str)):
                result = 0
            else:
                result = builtin_len(x)
            return result

        if filename is None:
            filename = self.filename('.csv')

        filename = os.path.join(os.path.join(os.path.dirname(filename),'raw_data'), os.path.basename(filename))

        if not os.path.exists(os.path.dirname(filename)):
            os.makedirs(os.path.dirname(filename))

        # if deque object, take the last dataset, which is the most recent
        if isinstance(self.data, deque):
            data = self.data[-1]
        elif isinstance(self.data, dict):
            data = self.data
        else:
            raise TypeError("script data variable has an invalid datatype! Must be deque or dict.")

        if len(set([len(v) for v in data.values()])) == 1 and len(np.shape(data.values()[0])) in [0, 1]:
            # if all entries of the dictionary are the same length and single column we can write the data into a single file
            if len(np.shape(data.values()[0]))==1:
                df = pd.DataFrame(data)
            else:
                df = pd.DataFrame.from_records([data])
            df.to_csv(filename, index=False)

        else:
            # otherwise, we write each entry into a separate file
            for key, value in data.iteritems():
                print value
                if len(value) == 0:
                    df = pd.DataFrame([value])
                else:
                    df = pd.DataFrame(value)

                # filename_new = os.path.join(os.path.dirname(filename),
                #       os.path.basename(filename).replace('.csv', '-{:s}.csv'.format(key)))
                #
                # if not os.path.exists(os.path.dirname(filename_new)):
                #     os.makedirs(os.path.dirname(filename_new))

                df.to_csv(filename.replace('.csv', '-{:s}.csv'.format(key)), index=False)
    def save_log(self, filename = None):
        """
        save log to file
        Returns:

        """

        if filename is None:
            filename = self.filename('-info.txt')

        with open(filename, 'w') as outfile:
            for item in self.log_data:
                outfile.write("%s\n" % item)
    def save_b26(self, filename=None):
        """
        saves the script settings to a file: filename is filename is not provided, it is created from internal function
        """
        if filename is None:
            filename = self.filename('.b26')

        save_b26_file(filename, scripts=self.to_dict())

    def save_image_to_disk(self, filename_1 = None, filename_2 = None):
        """
        creates an image using the scripts plot function and writes it to the disk
        for single plots (plot_type: 'main', 'aux')
            - if no filname provided take default name
        for double plots (plot_type: 'main', 'aux')
            - if no filnames provided take default name
            - if only one filname provided save only the plot for which name is provided
        Args:
            filename_1: filname for figure 1
            filename_2: filname for figure 1

        Returns: None

        """
        if self.plot_type in ('main', 'aux'):

            # create and save images
            if filename_1 is None:
                filename_1 = self.filename('-{:s}.jpg'.format(self.plot_type))

            fig = Figure()
            canvas = FigureCanvas(fig)
            ax = fig.add_subplot(1, 1, 1)
            self.plot(ax)
            fig.savefig(filename_1)

        elif self.plot_type in ('two'):

            # create and save images
            if (filename_1 is None) and (filename_2 is None):
                filename_1 = self.filename('-main.jpg')
                filename_2 = self.filename('-aux.jpg')

            fig_1 = Figure()
            canvas_1 = FigureCanvas(fig_1)
            ax_1 = fig_1.add_subplot(1, 1, 1)

            self.plot(ax_1)

            fig_2 = Figure()
            canvas_2 = FigureCanvas(fig_2)
            ax_2 = fig_2.add_subplot(1, 1, 1)


            self.plot(ax_1, ax_2)

            if filename_1 is not None:
                fig_1.savefig(filename_1)
            if filename_2 is not None:
                fig_2.savefig(filename_2)
    def save(self, filename):
        """
        saves the instance of the script to a file using pickle
        Args:
            filename: target filename

        """
        if filename is None:
            filename = self.filename('.b26s')
        print('savingg', filename)
        with open(filename, 'w') as outfile:
            outfile.write(cPickle.dumps(self.__dict__))

    @staticmethod
    def load(filename, instruments = None):
        """
        loads an script instance using pickle
        Args:
            filename: source filename
            instruments:
                optional - only needed if script requires instruments
                dictionary of form

                instruments = {
                name_of_instrument_1 : instance_of_instrument_1,
                name_of_instrument_2 : instance_of_instrument_2,
                ...
                }
        Returns:
            script_instance
            updated_instruments
        """
        with open(filename, 'r') as infile:
            dataPickle = infile.read()

        script_as_dict = cPickle.loads(dataPickle)
        script_class = script_as_dict['_script_class']

        script_instance, _, updated_instruments = Script.load_and_append({'script': script_class}, instruments = instruments)
        script_instance = script_instance['script']

        print(script_instance.instruments)

        # save references to instruments
        instruments = script_instance._instruments

        # update the script instance
        script_instance.__dict__ = script_as_dict

        # update references to instruments
        script_instance._instruments = instruments

        return script_instance, updated_instruments



    @staticmethod
    def load_data(path, tag = None, time_tag_in = None, data_name_in = None):
        """
        loads the data that has been save with Script.save
        Args:
            path: path to data
            time_tag: (optional) time tag of data if None, returns all data sets that have been found
        Returns:
            a dictionary with the data of form
            data = {time_tag:data_set}
            with
            data_set = {'varible1':data, 'variable2' : data, etc.}

            if there is only a single time tag, return data_set
        """
        data = {}
        if 'data' in os.listdir(path):
            data_files = os.listdir(path + '\data')
            data_names = set([f.split('.')[1] for f  in  data_files])
            time_tags = set(['_'.join(f.split('_')[0:3]) for f  in  data_files])


            for time_tag in time_tags:
                sub_data = {}
                for data_name in data_names:
                    file_path = "{:s}\\data\\{:s}*.{:s}".format(DIR, time_tag, data_name)
                    df = pd.read_csv(glob.glob(file_path)[0])
                    sub_data.update({data_name:list(df[list(df)[0]])})
                data.update({time_tag: sub_data})

        else:
            data_files = glob.glob(path + '*.csv')
            for data_file in data_files:
                time_tag = '_'.join(data_file.split('\\')[-1].split('_')[0:3])
                df = pd.read_csv(data_file)
                data_names = list(df)

                # test if first row is a row of headers or numbers
                try:
                    float(data_names[0])
                    has_header = False
                except ValueError:
                    has_header = True
                    print('value_error')

                if has_header:
                    data.update({time_tag:
                                     {data_name: list(df[data_name]) for data_name in data_names}
                                 })
                else:

                    data_name = data_file.split('\\')[-1].split('-')[-1].split('.')[0]
                    if time_tag in data:
                        data[time_tag].update({data_name: df})
                    else:
                        data.update({time_tag: {data_name: df}})

        if time_tag_in:
            # if user specifies a time_tag we only return that specific data set
            if data_name_in ==None:
                data = data[time_tag_in]
            else:
                data = data[time_tag_in][data_name_in]
        elif data_name_in:
            # return data of last data set
            #todo: current broken, need to fix
            #data = data[sorted(data.keys())[-1]][data_name_in]
            time_keys = sorted(data.keys())
            time_keys.reverse()
            for time in time_keys:
                try:
                    data = data[time][data_name_in].values
                    break
                except KeyError:
                    print('key_error')
                    continue
            if type(data) == dict and not data:
                raise ValueError('Could not find a file with this name at any time_tag')


        elif len(data) == 1:
            # if there is only one data_set, we strip of the time_tag level
            data = data[data.keys()[0]]

        return data
    @staticmethod
    def load_and_append(script_dict, scripts = None, instruments = None, log_function = None, data_path = None):
        """
        load script from script_dict and append to scripts, if additional instruments are required create them and add them to instruments

        Args:
            script_dict: dictionary of form

                script_dict = {
                name_of_script_1 :
                    {"settings" : settings_dictionary, "class" : name_of_class}
                name_of_instrument_2 :
                    {"settings" : settings_dictionary, "class" : name_of_class}
                ...
                }

            or

                script_dict = {
                name_of_script_1 : name_of_class,
                name_of_script_2 : name_of_class
                ...
                }

            where name_of_class is either a class or the name of a class

            scripts: dictionary of form

                scripts = {
                name_of_script_1 : instance_of_instrument_1,
                name_of_script_2 : instance_of_instrument_2,
                ...
                }

            instruments: dictionary of form

                instruments = {
                name_of_instrument_1 : instance_of_instrument_1,
                name_of_instrument_2 : instance_of_instrument_2,
                ...
                }
            log_function: function that takes a string

            data_path: absolute path where data is saved, in case the path in the script is definded as a relative path

        Returns:
                dictionary of form
                script_dict = { name_of_script_1 : script_1_instance, name_of_script_2 : script_2_instance, ...}
                load_failed = {name_of_script_1: exception_1, name_of_script_2: exception_2, ....}
                updated_instruments = {name_of_instrument_1 : instance_of_instrument_1, ..}

        """

        if scripts is None:
            scripts = {}
        if instruments is None:
            instruments = {}

        load_failed = {}
        updated_scripts = {}
        updated_scripts.update(scripts)
        updated_instruments = {}
        updated_instruments.update(instruments)

        def get_script_information(script_information):
            """

            Args:
                script_information: information of the script. This can be
                    - a dictionary
                    - a Script instance
                    - name of Script class

            Returns: module_path, script_class_name, script_settings, script_instruments, script_sub_scripts

            """
            script_settings = None
            script_instruments = None
            script_sub_scripts = None
            script_class_name = None
            if isinstance(script_information, dict):
                script_settings = script_information['settings']
                script_class_name = str(script_information['class'])
                if 'instruments' in script_information:
                    script_instruments = script_information['instruments']
                if 'scripts' in script_information:
                    script_sub_scripts = script_information['scripts']
            elif isinstance(script_information, str):
                script_class_name = script_information
            elif issubclass(script_information, Script):
                # watch out when testing this code from __main__, then classes might not be identified correctly because the path is different
                # to avoid this problem call from src.core import Script (otherwise the path to Script is __main__.Script)
                script_class_name = script_information.__name__
            if len(script_class_name.split('.')) == 1:
                module_path = 'src.scripts'
            else:
                module_path = 'src.scripts.' + '.'.join(script_class_name.split('.')[0:-1])
                script_class_name = script_information.split('.')[-1]

            return module_path, script_class_name, script_settings, script_instruments, script_sub_scripts

        def get_instruments(class_of_script, script_instruments, instruments):
            """

            creates the dictionary with the instruments needed for the script and update the instrument dictionary if new instruments are required

            Args:
                class_of_script: the class of the script
                instruments: the instruments that have been loaded already

            Returns: dictionary with the instruments that the script needs and the updated instruments dictionary

            """
            default_instruments = getattr(class_of_script, '_INSTRUMENTS')
            instrument_dict = {}
            instruments_updated = {}
            instruments_updated.update(instruments)
            # check if instruments needed by script already exist, if not create an instance
            for instrument_name, instrument_class in default_instruments.iteritems():
                # check if instruments needed by script already exist
                instrument = [instance for name, instance in instruments_updated.iteritems() if
                              isinstance(instance, instrument_class) and name == instrument_name]
                if len(instrument) == 0:
                    # create new instance of instrument
                    instruments_updated, __ = Instrument.load_and_append({instrument_name: instrument_class.__name__}, instruments_updated)

                if script_instruments is not None and instrument_name in script_instruments:
                    instrument_settings_dict = script_instruments[instrument_name]['settings']
                else:
                    instrument_settings_dict = instruments_updated[instrument_name].settings

                instrument_instance = instruments_updated[instrument_name]

                # make a deepcopy of _DEFAULT_SETTINGS to get a parameter object
                instrument_settings = deepcopy(instrument_instance._DEFAULT_SETTINGS)
                #now update parameter object with new values


                instrument_settings.update(instrument_settings_dict)



                instrument_dict.update({instrument_name: {"instance":instrument_instance, "settings":instrument_settings}})


            return instrument_dict, instruments_updated

        def get_sub_scripts(class_of_script, instruments, sub_scripts_dict):
            """

            creates the dictionary with the sub scripts needed by the script and updates the instrument dictionary if new instruments are required

            Args:
                class_of_script: the class of the script
                instruments: the instruments that have been loaded already

            Returns:dictionary with the sub scripts that the script needs

            """
            default_scripts = getattr(class_of_script, '_SCRIPTS')
            #
            # create instruments that script needs
            sub_scripts = {}

            sub_scripts, scripts_failed, instruments_updated = Script.load_and_append(default_scripts, sub_scripts, instruments)

            if sub_scripts_dict is not None:
                for k, v in sub_scripts_dict.iteritems():
                    #update settings, updates instrument and settings
                    sub_scripts[k].update(v)

            return sub_scripts, instruments_updated

        for script_name, script_class_name in script_dict.iteritems():

            # check if script already exists
            if script_name in scripts.keys():
                print('WARNING: script {:s} already exists. Did not load!'.format(script_name))
                load_failed[script_name] = ValueError('script {:s} already exists. Did not load!'.format(script_name))
            else:
                module_path, script_class_name, script_settings, script_instruments, script_sub_scripts = get_script_information(script_class_name)

                script_instance = None

                # try to import the script
                module = __import__(module_path, fromlist=[script_class_name])
                # this returns the name of the module that was imported.
                class_of_script = getattr(module, script_class_name)

                #  ========= get the instruments that are needed by the script =========
                #try:
                script_instruments, updated_instruments = get_instruments(class_of_script, script_instruments, updated_instruments)
                #  ========= create the scripts that are needed by the script =========

                sub_scripts, updated_instruments = get_sub_scripts(class_of_script, updated_instruments, script_sub_scripts)

                class_creation_string = ''
                if script_instruments:
                    class_creation_string += ', instruments = script_instruments'
                if sub_scripts:
                    class_creation_string += ', scripts = sub_scripts'
                if script_settings:
                    class_creation_string += ', settings = script_settings'
                if log_function:
                    class_creation_string += ', log_function = log_function'
                if data_path:
                    class_creation_string += ', data_path = data_path'
                class_creation_string = 'class_of_script(name=script_name{:s})'.format(class_creation_string)

                script_instance = eval(class_creation_string)
                updated_scripts.update({script_name :script_instance})
                #except Exception as inst:
                #    load_failed[script_name] = inst
                    # raise inst
                    # loaded_failed.append(script_name)

        return updated_scripts, load_failed, updated_instruments

    def duplicate(self):
        """
        create an copy of the script

        Returns:

        """

        # get settings of script
        class_of_script = self.__class__
        script_name = self.name
        script_instruments = self.instruments
        sub_scripts = self.scripts
        script_settings = self.settings
        log_function = self.log_function
        data_path = self.data_path


        #create a new instance of same script type
        class_creation_string = ''
        if script_instruments != {}:
            class_creation_string += ', instruments = script_instruments'
        if sub_scripts != {}:
            class_creation_string += ', scripts = sub_scripts'
        if script_settings != {}:
            class_creation_string += ', settings = script_settings'
        if log_function is not None:
            class_creation_string += ', log_function = log_function'
        if data_path is not None:
            class_creation_string += ', data_path = data_path'
        class_creation_string = 'class_of_script(name=script_name{:s})'.format(class_creation_string)
        # create instance
        print(class_creation_string)
        script_instance = eval(class_creation_string)

        # copy some other properties that might be checked later for the duplicated script
        script_instance.data = deepcopy(self.data)
        script_instance.start_time = self.start_time
        script_instance.end_time = self.end_time
        script_instance.is_running = self.is_running

        return script_instance

    def plot(self, axes):
        """
        plots the data contained in self.data, which should be a dictionary or a deque of dictionaries
        for the latter use the last entry

        """

        if isinstance(self.data, deque):
            data = self.data[-1]
        elif isinstance(self.data, dict):
            data = self.data
        else:
            data = {}

        assert isinstance(data, dict)

        if data == {}:
            self.log("warning, not data found that can be plotted")
        else:
            for key, value in data.iteritems():
                axes.plot(value)

class QThreadWrapper(QThread):


    updateProgress = Signal(int)

    def __init__(self, script):
        """
        This is a wrapper for scripts that are not QThread, to execute them on a different thread than the gui
        Args:
            script: script to be executed

        """
        self.script = script
        QThread.__init__(self)

    def run(self):

        self._running = True
        self.updateProgress.emit(1)
        self.script.run()
        self.updateProgress.emit(100)






if __name__ == '__main__':
    from src.core.read_write_functions import load_b26_file
    from src.instruments import DummyInstrument
    from src.scripts import ScriptDummyWithInstrument, ScriptDummy

    from src.core import Script

    f = 'Z:\\Lab\\Cantilever\\Measurements\\_tmp\\test.b26s'
    script, instruments = Script.load(f)

    print(script)

    print('----')
    print(instruments)

    # #
    # s, _, _ = Script.load_and_append({'s1':'ScriptDummyWithInstrument'})
    # s = s['s1']
    # print('------')
    # # s = ScriptDummyWithInstrument()
    #
    # # print(s)
    # s.update({'count': 55})
    # s.save('Z:\\Lab\\Cantilever\\Measurements\\_tmp\\test.b26s')
    # #
    # print(s)

    # s2 = ScriptDummyWithInstrument()
    # print(s2)
    # s2.load('Z:\\Lab\\Cantilever\\Measurements\\_tmp\\test.b26s')
    #
    # # print(s)
    # print('----')
    # print(s2)
