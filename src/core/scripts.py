import datetime
import time
from abc import ABCMeta, abstractmethod, abstractproperty
from copy import deepcopy
from src.core.parameter import Parameter
from src.core.instruments import Instrument
from PyQt4 import QtCore
from collections import deque
import os
import pandas as pd
import glob
import json as json

from PyQt4.QtCore import pyqtSignal, QObject, pyqtSlot

from src.core.read_write_functions import save_b26_file
import numpy as np
from __builtin__ import len as builtin_len
from matplotlib.backends.backend_pdf import FigureCanvasPdf as FigureCanvas # use this to avoid error that plotting should only be done on main thread
from matplotlib.figure import Figure

# cPickle module implements the same algorithm as pickle, in C instead of Python.
# It is many times faster than the Python implementation, but does not allow the user to subclass from Pickle.
import cPickle


class Script(QObject):
    #This is the signal that will be emitted during the processing.
    #By including int as an argument, it lets the signal know to expect
    #an integer argument when emitting.
    updateProgress = pyqtSignal(int)
    finished = pyqtSignal()

    _DEFAULT_SETTINGS = [
        Parameter('path',  'tmp_data', str, 'path to folder where data is saved'),
        Parameter('tag', 'some_name'),
        Parameter('save', False, bool,'check to automatically save data'),
    ]

    def __init__(self, name=None, settings=None, instruments=None, scripts=None, log_function=None, data_path=None):
        """
        executes scripts and stores script parameters and settings
        Args:
            name (optional):  name of script, if not provided take name of function
            settings (optional): a Parameter object that contains all the information needed in the script
            instruments (optional): instruments used in the script
            scripts (optional):  sub_scripts used in the script
            log_function(optional): function reference that takes a string
        """
        QObject.__init__(self)

        self._script_class = self.__class__.__name__

        if name is None:
            name = self.__class__.__name__
        self.name = name

        self._instruments = {}
        if instruments is None:
            instruments = {}
        else:
            assert isinstance(instruments, dict)
            assert set(self._INSTRUMENTS.keys()) <= set(instruments.keys())

        self.data_path = data_path

        self.instruments = {key: instruments[key] for key in self._INSTRUMENTS.keys()}

        self._scripts = {}
        if scripts is None:
            scripts = {}
        self.scripts = scripts

        # set end time to be before start time if script hasn't been excecuted this tells us
        self.start_time = datetime.datetime.now()
        self.end_time = self.start_time - datetime.timedelta(seconds=1)


        # self._settings = deepcopy(self._DEFAULT_SETTINGS)
        self._settings = Parameter(self._DEFAULT_SETTINGS+ Script._DEFAULT_SETTINGS)

        if settings is not None:
            self.update(settings)
        self._abort = False
        self.is_running = False

        # data hold the data generated by the script,
        # this should either be a dictionary or a deque of dictionaries
        self.data = {}

        # a log for status outputs
        self.log_data = deque()
        # this can be overwritten
        self.log_function = log_function

        # default value is 'none', overwrite this in script if it has plotting capabilities
        self._plot_refresh = True

    @property
    def data_path(self):
        return self._data_path

    @data_path.setter
    def data_path(self, path):
        # check is path is a valid path string
        if path is not None and path is not '':
            # assert os.path.isdir(path)
            if not os.path.isdir(path):
                print('{:s} created'.format(path))
                os.mkdir(path)

        self._data_path = path


    # @abstractmethod
    def _function(self):
        """
        This is the actual function that will be executed. It uses only information that is provided in the settings property
        will be overwritten in the __init__
        """
        # some generic function
        raise NotImplementedError

    def log(self, string):
        """
        appends input string to log file and sends it to log function (self.log_function)
        Returns:

        """

        self.log_data.append(string)
        if self.log_function is None:
            print(string)
        else:
            self.log_function(string)

    # @property
    # def _DEFAULT_SETTINGS(self):
    #     """
    #     returns the default parameter_list of the script this function should be over written in any subclass
    #     """
    #     raise NotImplementedError("Subclass did not implement _DEFAULT_SETTINGS")

    @property
    def _INSTRUMENTS(self):
        """

        Returns: a dictionary of the instruments, where key is the instrument name and value is the instrument class
        if there is not instrument it should return an empty dict

        """
        raise NotImplementedError("Subclass did not implement _INSTRUMENTS")

    @property
    def _SCRIPTS(self):
        """

        Returns: a dictionary of the instruments, where the key is the instrument name and value is the instrument class
        if there is not instrument it should return an empty dict

        """
        raise NotImplementedError("Subclass did not implement _SCRIPTS")

    def __str__(self):

        output_string = '{:s} (class type: {:s})\n'.format(self.name, self.__class__.__name__)

        output_string += 'settings:\n'
        for key, value in self.settings.iteritems():
            output_string += "{:s} : {:s}\n".format(key, str(value))
        return output_string

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if isinstance(value, unicode):
            value = str(value)

        assert isinstance(value, str), str(value) + ' is not a string'
        self._name = value

    @property
    def instrumets(self):
        return self._instruments
    @instrumets.setter
    def instruments(self, instrument_dict):
        assert isinstance(instrument_dict, dict)
        # checks if all the keys in _INSTRUMENTS are contained in instrument_dict
        assert set(self._INSTRUMENTS.keys()) <= set(instrument_dict.keys()), "{:s}: needs instruments {:s} but received {:s}".format(self.name, str( self._INSTRUMENTS.keys()), str(instrument_dict.keys()))
        for key, value in self._INSTRUMENTS.iteritems():
            self._instruments.update({key: instrument_dict[key]})


    @property
    def scripts(self):
        return self._scripts

    @scripts.setter
    def scripts(self, script_dict):
        assert isinstance(script_dict, dict)
        assert set(script_dict.keys()) == set(self._SCRIPTS.keys()), "{:s}: set subscripts {:s}, received {:s}".format(self.name, str(script_dict.keys()), str( self._SCRIPTS.keys()))

        for key, value in self._SCRIPTS.iteritems():
            assert isinstance(script_dict[key], self._SCRIPTS[key])
            self._scripts.update({key: script_dict[key]})

    @property
    def settings(self):
        '''
        :return: returns the settings of the script
        settings contain Parameters, Instruments and Scripts
        '''
        return self._settings

    def update(self, settings):
        '''
        updates the internal dictionary
        Args:
            settings: parameters to be set
        # mabe in the future:
        # Returns: boolean that is true if update successful

        '''
        if 'settings' in settings:
            self._settings.update(settings['settings'])
        else:
            self._settings.update(settings)

        if 'instruments' in settings:
            for instrument_name, instrument_setting in settings['instruments'].iteritems():
                self.instruments[instrument_name]['settings'].update(instrument_setting['settings'])

        if 'scripts' in settings:
            for script_name, script_setting in settings['scripts'].iteritems():
                self.scripts[script_name].update(script_setting)

    @property
    def end_time(self):
        """
        time when script execution started
        :return:
        """
        return self._time_stop

    @end_time.setter
    def end_time(self, value):
        assert isinstance(value, datetime.datetime)
        self._time_stop = value

    @property
    def start_time(self):
        """
        time when script execution started
        :return:
        """
        return self._time_start
    @start_time.setter
    def start_time(self, value):
        assert isinstance(value, datetime.datetime)
        self._time_start = value

    @property
    def excecution_time(self):
        """
        :return: script excecition time as time_delta object to get time in seconds use .total_seconds()
        """
        return self.end_time - self.start_time

    @pyqtSlot(int)
    def _receive_signal(self, progress):
        """
        this function takes care of signals emitted by the subscripts
        the default behaviour is that it just reemits the signal
        Args:
            progress: progress of subscript
        """
        self.updateProgress.emit(progress)
    def run(self):
        """
        executes the script
        :return: boolean if execution of script finished succesfully
        """
        self.is_running = True
        self.log_data.clear()

        # update the datapath of the subscripts and connect their progress signal to the receive slot
        for subscript  in self.scripts.values():
            subscript.data_path = self.data_path
            subscript.updateProgress.connect(self._receive_signal)

        self.start_time  = datetime.datetime.now()
        self.log('starting script {:s} at {:s} on {:s}'.format(self.name, self.start_time.strftime('%H:%M:%S'),self.start_time.strftime('%d/%m/%y')))
        self._abort = False
        self._plot_refresh = True # flag that requests that plot axes are refreshed when self.plot is called next time
        self._function()
        self.end_time  = datetime.datetime.now()
        self.log('script {:s} finished at {:s} on {:s}'.format(self.name, self.end_time.strftime('%H:%M:%S'),self.end_time.strftime('%d/%m/%y')))
        success = not self._abort
        self.is_running = False

        print(self.name, ' FINISHED!!!!!')

        self.finished.emit()



    def stop(self):
        self._abort = True

    def validate(self):
        pass

    def filename(self, appendix = None):
        """
        creates a filename based
        Args:
            appendix: appendix for file

        Returns: filename

        """

        # if provided path is a relative path and self.data_path exists, build path
        if os.path.isabs(self.settings['path']) == False and self.data_path is not None:
            path = os.path.join(self.data_path, self.settings['path'])
        else:
            path = self.settings['path']

        tag = self.settings['tag']

        filename = os.path.join(path, "{:s}_{:s}".format(self.start_time.strftime('%y%m%d-%H_%M_%S'),tag))

        if os.path.exists(filename) == False:
            os.makedirs(filename)

        if appendix is not None:
            filename = os.path.join(filename,  "{:s}_{:s}{:s}".format(self.start_time.strftime('%y%m%d-%H_%M_%S'),tag,appendix))

        return filename
    def to_dict(self):
        """

        Returns: itself as a dictionary

        """

        dictator = {self.name: {'class' : self.__class__.__name__}}

        if self.scripts != {}:
            dictator[self.name].update({'scripts': {} })
            for subscript_name, subscript in self.scripts.iteritems():
                dictator[self.name]['scripts'].update(subscript.to_dict() )

        if self.instruments != {}:
            # dictator[self.name].update({'instruments': self.instruments})
            # dictator[self.name].update({'instruments': {} })
            # for instrument_name, instrument in self.instruments.iteritems():
            #     dictator[self.name]['instruments'].update(instrument.to_dict())

            dictator[self.name].update({'instruments': {
                instrument_name: {'class': instrument['instance'].__class__.__name__, 'settings':instrument['settings']}
                for instrument_name, instrument in self.instruments.iteritems()
            }})

        dictator[self.name]['settings'] = self.settings

        return dictator
    def save_data(self, filename = None, data_tag = None):
        """
        saves the script data to a file
        filename: target filename, if not provided, it is created from internal function
        data_tag: string, if provided save only the data that matches the tag, otherwise save all data
        Returns:

        """


        def len(x):
            """
            overwrite the buildin len function to cover cases that don't have a length, like int or float
            and to catch string as objects of length 0
            Args:
                x: quantity of which we want to find the length
            Returns: length of x

            """
            if isinstance(x, (int, float, str)):
                result = 0
            else:
                result = builtin_len(x)
            return result

        if filename is None:
            filename = self.filename('.csv')

        filename = os.path.join(os.path.join(os.path.dirname(filename),'raw_data'), os.path.basename(filename))

        if not os.path.exists(os.path.dirname(filename)):
            os.makedirs(os.path.dirname(filename))

        # if deque object, take the last dataset, which is the most recent
        if isinstance(self.data, deque):
            data = self.data[-1]
        elif isinstance(self.data, dict):
            data = self.data
        else:
            raise TypeError("script data variable has an invalid datatype! Must be deque or dict.")


        if data_tag is None:
            if len(set([len(v) for v in data.values()])) == 1 and len(np.shape(data.values()[0])) in [0, 1]:
                # if all entries of the dictionary are the same length and single column we can write the data into a single file
                if len(np.shape(data.values()[0]))==1:
                    df = pd.DataFrame(data)
                else:
                    df = pd.DataFrame.from_records([data])
                df.to_csv(filename, index=False)

            else:
                # otherwise, we write each entry into a separate file
                for key, value in data.iteritems():
                    if len(value) == 0:
                        df = pd.DataFrame([value])
                    else:
                        df = pd.DataFrame(value)

                    df.to_csv(filename.replace('.csv', '-{:s}.csv'.format(key)), index=False)

        else:
            # save only the data for which a key has been provided
            assert data_tag in data.keys()
            value = data[data_tag]
            if len(value) == 0:
                df = pd.DataFrame([value])
            else:
                df = pd.DataFrame(value)
            df.to_csv(filename, index=False)

    def save_log(self, filename = None):
        """
        save log to file
        Returns:

        """

        if filename is None:
            filename = self.filename('-info.txt')

        with open(filename, 'w') as outfile:
            for item in self.log_data:
                outfile.write("%s\n" % item)
    def save_b26(self, filename=None):
        """
        saves the script settings to a file: filename is filename is not provided, it is created from internal function
        """
        if filename is None:
            filename = self.filename('.b26')

        save_b26_file(filename, scripts=self.to_dict())

    def save_image_to_disk(self, filename_1 = None, filename_2 = None):
        """
        creates an image using the scripts plot function and writes it to the disk
        for single plots (plot_type: 'main', 'aux')
            - if no filname provided take default name
        for double plots (plot_type: 'main', 'aux')
            - if no filnames provided take default name
            - if only one filname provided save only the plot for which name is provided
        Args:
            filename_1: filname for figure 1
            filename_2: filname for figure 1

        Returns: None

        """
        # if self.plot_type in ('main', 'aux'):
        #
        #     # create and save images
        #     if filename_1 is None:
        #         filename_1 = self.filename('-{:s}.jpg'.format(self.plot_type))
        #
        #     fig = Figure()
        #     self._plot_refresh = True #need to set up a new plot
        #     canvas = FigureCanvas(fig) #need to create a canvas to have the figure be somewhere, otherwise can't save
        #     self.plot([fig])
        #     fig.savefig(filename_1)
        #
        # elif self.plot_type in ('two'):

        # create and save images
        if (filename_1 is None) and (filename_2 is None):
            filename_1 = self.filename('-plt1.jpg')
            filename_2 = self.filename('-plt2.jpg')

        fig_1 = Figure()
        canvas_1 = FigureCanvas(fig_1)

        fig_2 = Figure()
        canvas_2 = FigureCanvas(fig_2)

        self._plot_refresh = True
        self.plot([fig_1, fig_2])

        if filename_1 is not None and not fig_1.axes == []:
            fig_1.savefig(filename_1)
        if filename_2 is not None and not fig_2.axes == []:
            fig_2.savefig(filename_2)

    def save(self, filename):
        """
        saves the instance of the script to a file using pickle
        Args:
            filename: target filename

        """
        if filename is None:
            filename = self.filename('.b26s')
        # print('saving', filename)
        with open(filename, 'w') as outfile:
            outfile.write(cPickle.dumps(self.__dict__))

    @staticmethod
    def load(filename, instruments = None):
        """
        loads an script instance using pickle
        Args:
            filename: source filename
            instruments:
                optional - only needed if script requires instruments
                dictionary of form

                instruments = {
                name_of_instrument_1 : instance_of_instrument_1,
                name_of_instrument_2 : instance_of_instrument_2,
                ...
                }
        Returns:
            script_instance
            updated_instruments
        """
        with open(filename, 'r') as infile:
            dataPickle = infile.read()

        script_as_dict = cPickle.loads(dataPickle)
        script_class = script_as_dict['_script_class']

        script_instance, _, updated_instruments = Script.load_and_append({'script': script_class}, instruments = instruments)
        script_instance = script_instance['script']

        # save references to instruments
        instruments = script_instance._instruments

        # update the script instance
        script_instance.__dict__ = script_as_dict

        # update references to instruments
        script_instance._instruments = instruments

        return script_instance, updated_instruments

    @staticmethod
    def load_data(path):
        """
        loads the data that has been save with Script.save.
        Args:
            path: path to folder saved vy Script.save or raw_data folder within
        Returns:
            a dictionary with the data of form
            data = {param_1_name: param_1_data, ...}
        """

        # check that path exists
        if not os.path.exists(path):
            raise AttributeError('Path given does not exist!')

        # if raw_data folder exists, get a list of directories from within it; otherwise, get names of all .csv files in
        # current directory

        data = {}
        if 'raw_data' in os.listdir(path):
            data_files = os.listdir(os.path.join(path, 'raw_data/'))
            path = os.path.join(path, 'raw_data/')

        else:
            data_files = glob.glob(os.path.join(path, '*.csv'))

        # If no data files were found, raise error
        if not data_files:
            raise AttributeError('Could not find data files in {s}'.format(path))

        # import data from each csv
        for data_file in data_files:

            # get data name, read the data from the csv, and save it to dictionary
            data_name = data_file.split('-')[-1][0:-4] # JG: why do we strip of the date?
            imported_data_df = pd.read_csv(os.path.join(path, data_file))


            # check if there are headers, i.e. check if all headers are of type str
            column_headers = list(imported_data_df.columns.values)
            if sum([int(isinstance(x, str)) for x in column_headers]) == len(column_headers):
                    data = {h: imported_data_df[h].as_matrix() for h in column_headers}
            else:
                # note, np.squeeze removes extraneous length-1 dimensions from the returned 'matrix' from the dataframe
                data[data_name] = np.squeeze(imported_data_df.as_matrix())

        return data

        # else:
        #     data_files = glob.glob(path + '*.csv')
        #     for data_file in data_files:
        #         time_tag = '_'.join(data_file.split('\\')[-1].split('_')[0:3])
        #         df = pd.read_csv(data_file)
        #         data_names = list(df)
        #
        #         # test if first row is a row of headers or numbers
        #         try:
        #             float(data_names[0])
        #             has_header = False
        #         except ValueError:
        #             has_header = True
        #             print('value_error')
        #
        #         if has_header:
        #             data.update({time_tag:
        #                              {data_name: list(df[data_name]) for data_name in data_names}
        #                          })
        #         else:
        #
        #             data_name = data_file.split('\\')[-1].split('-')[-1].split('.')[0]
        #             if time_tag in data:
        #                 data[time_tag].update({data_name: df})
        #             else:
        #                 data.update({time_tag: {data_name: df}})

        # if time_tag_in:
        #     # if user specifies a time_tag we only return that specific data set
        #     if data_name_in ==None:
        #         data = data[time_tag_in]
        #     else:
        #         data = data[time_tag_in][data_name_in]
        # elif data_name_in:
        #     # return data of last data set
        #     #todo: currently broken, need to fix
        #     #data = data[sorted(data.keys())[-1]][data_name_in]
        #     time_keys = sorted(data.keys())
        #     time_keys.reverse()
        #     for time in time_keys:
        #         try:
        #             data = data[time][data_name_in].values
        #             break
        #         except KeyError:
        #             print('key_error')
        #             continue
        #     if type(data) == dict and not data:
        #         raise ValueError('Could not find a file with this name at any time_tag')
        #
        #
        # elif len(data) == 1:
        #     # if there is only one data_set, we strip of the time_tag level
        #     data = data[data.keys()[0]]
        #
        # return data
    @staticmethod
    def load_and_append(script_dict, scripts = None, instruments = None, log_function = None, data_path = None):
        """
        load script from script_dict and append to scripts, if additional instruments are required create them and add them to instruments

        Args:
            script_dict: dictionary of form

                script_dict = {
                name_of_script_1 :
                    {"settings" : settings_dictionary, "class" : name_of_class}
                name_of_instrument_2 :
                    {"settings" : settings_dictionary, "class" : name_of_class}
                ...
                }

            or

                script_dict = {
                name_of_script_1 : name_of_class,
                name_of_script_2 : name_of_class
                ...
                }

            where name_of_class is either a class or the name of a class

            scripts: dictionary of form

                scripts = {
                name_of_script_1 : instance_of_instrument_1,
                name_of_script_2 : instance_of_instrument_2,
                ...
                }

            instruments: dictionary of form

                instruments = {
                name_of_instrument_1 : instance_of_instrument_1,
                name_of_instrument_2 : instance_of_instrument_2,
                ...
                }
            log_function: function that takes a string

            data_path: absolute path where data is saved, in case the path in the script is definded as a relative path

        Returns:
                dictionary of form
                script_dict = { name_of_script_1 : script_1_instance, name_of_script_2 : script_2_instance, ...}
                load_failed = {name_of_script_1: exception_1, name_of_script_2: exception_2, ....}
                updated_instruments = {name_of_instrument_1 : instance_of_instrument_1, ..}

        """

        if scripts is None:
            scripts = {}
        if instruments is None:
            instruments = {}

        load_failed = {}
        updated_scripts = {}
        updated_scripts.update(scripts)
        updated_instruments = {}
        updated_instruments.update(instruments)

        def get_script_information(script_information):
            """

            Args:
                script_information: information of the script. This can be
                    - a dictionary
                    - a Script instance
                    - name of Script class

            Returns: module_path, script_class_name, script_settings, script_instruments, script_sub_scripts

            """
            script_settings = None
            script_instruments = None
            script_sub_scripts = None
            script_class_name = None
            if isinstance(script_information, dict):
                script_settings = script_information['settings']
                script_class_name = str(script_information['class'])
                if 'instruments' in script_information:
                    script_instruments = script_information['instruments']
                if 'scripts' in script_information:
                    script_sub_scripts = script_information['scripts']
            elif isinstance(script_information, str):
                script_class_name = script_information
            elif issubclass(script_information, Script):
                # watch out when testing this code from __main__, then classes might not be identified correctly because the path is different
                # to avoid this problem call from src.core import Script (otherwise the path to Script is __main__.Script)
                script_class_name = script_information.__name__
            if len(script_class_name.split('.')) == 1:
                module_path = 'src.scripts'
            else:
                module_path = 'src.scripts.' + '.'.join(script_class_name.split('.')[0:-1])
                script_class_name = script_information.split('.')[-1]

            return module_path, script_class_name, script_settings, script_instruments, script_sub_scripts

        def get_instruments(class_of_script, script_instruments, instruments):
            """

            creates the dictionary with the instruments needed for the script and update the instrument dictionary if new instruments are required

            Args:
                class_of_script: the class of the script
                instruments: the instruments that have been loaded already

            Returns: dictionary with the instruments that the script needs and the updated instruments dictionary

            """
            default_instruments = getattr(class_of_script, '_INSTRUMENTS')
            instrument_dict = {}
            instruments_updated = {}
            instruments_updated.update(instruments)
            # check if instruments needed by script already exist, if not create an instance
            for instrument_name, instrument_class in default_instruments.iteritems():
                # check if instruments needed by script already exist
                instrument = [instance for name, instance in instruments_updated.iteritems() if
                              isinstance(instance, instrument_class) and name == instrument_name]
                if len(instrument) == 0:
                    # create new instance of instrument
                    instruments_updated, __ = Instrument.load_and_append({instrument_name: instrument_class.__name__}, instruments_updated)
                if script_instruments is not None and instrument_name in script_instruments:
                    instrument_settings_dict = script_instruments[instrument_name]['settings']
                else:
                    instrument_settings_dict = instruments_updated[instrument_name].settings

                instrument_instance = instruments_updated[instrument_name]

                # make a deepcopy of _DEFAULT_SETTINGS to get a parameter object
                instrument_settings = deepcopy(instrument_instance._DEFAULT_SETTINGS)
                #now update parameter object with new values


                instrument_settings.update(instrument_settings_dict)



                instrument_dict.update({instrument_name: {"instance":instrument_instance, "settings":instrument_settings}})


            return instrument_dict, instruments_updated

        def get_sub_scripts(class_of_script, instruments, sub_scripts_dict):
            """

            creates the dictionary with the sub scripts needed by the script and updates the instrument dictionary if new instruments are required

            Args:
                class_of_script: the class of the script
                instruments: the instruments that have been loaded already

            Returns:dictionary with the sub scripts that the script needs

            """
            default_scripts = getattr(class_of_script, '_SCRIPTS')
            #
            # create instruments that script needs
            sub_scripts = {}
            sub_scripts, scripts_failed, instruments_updated = Script.load_and_append(default_scripts, sub_scripts, instruments)

            if sub_scripts_dict is not None:
                for k, v in sub_scripts_dict.iteritems():
                    #update settings, updates instrument and settings
                    sub_scripts[k].update(v)

            if len(scripts_failed)>0:
                raise ImportError('script {:s}: failed to load subscripts'.format(class_of_script))
            return sub_scripts, instruments_updated
            # return sub_scripts_dict, instruments_updated

        for script_name, script_class_name in script_dict.iteritems():

            # check if script already exists
            if script_name in scripts.keys():
                print('WARNING: script {:s} already exists. Did not load!'.format(script_name))
                load_failed[script_name] = ValueError('script {:s} already exists. Did not load!'.format(script_name))
            else:
                module_path, script_class_name, script_settings, script_instruments, script_sub_scripts = get_script_information(script_class_name)

                script_instance = None

                # try to import the script
                module = __import__(module_path, fromlist=[script_class_name])
                # this returns the name of the module that was imported.
                class_of_script = getattr(module, script_class_name)

                #  ========= create the instruments that are needed by the script =========
                try:
                    script_instruments, updated_instruments = get_instruments(class_of_script, script_instruments, updated_instruments)
                except Exception, err:
                    print('loading script {:s} failed. Could not load instruments!'.format(script_name))
                    load_failed[script_name] = err
                    continue
                #  ========= create the subscripts that are needed by the script =========
                try:
                    sub_scripts, updated_instruments = get_sub_scripts(class_of_script, updated_instruments, script_sub_scripts)
                except Exception, err:
                    print('loading script {:s} failed. Could not load subscripts!'.format(script_name))
                    load_failed[script_name] = err
                    continue
                # print('==> {:s}: start creation'.format(script_name))
                class_creation_string = ''
                if script_instruments:
                    class_creation_string += ', instruments = script_instruments'
                if sub_scripts:
                    class_creation_string += ', scripts = sub_scripts'
                if script_settings:
                    class_creation_string += ', settings = script_settings'
                if log_function:
                    class_creation_string += ', log_function = log_function'
                if data_path:
                    class_creation_string += ', data_path = data_path'
                class_creation_string = 'class_of_script(name=script_name{:s})'.format(class_creation_string)

                try:
                    script_instance = eval(class_creation_string)
                except Exception, err:
                    print('loading script {:s} failed. Could not create script!'.format(script_name))
                    load_failed[script_name] = err
                    continue
                updated_scripts.update({script_name :script_instance})

        return updated_scripts, load_failed, updated_instruments

    def duplicate(self):
        """
        create an copy of the script

        Returns:

        """

        # get settings of script
        class_of_script = self.__class__
        script_name = self.name
        script_instruments = self.instruments
        sub_scripts = self.scripts
        script_settings = self.settings
        log_function = self.log_function
        data_path = self.data_path


        #create a new instance of same script type
        class_creation_string = ''
        if script_instruments != {}:
            class_creation_string += ', instruments = script_instruments'
        if sub_scripts != {}:
            class_creation_string += ', scripts = sub_scripts'
        if script_settings != {}:
            class_creation_string += ', settings = script_settings'
        if log_function is not None:
            class_creation_string += ', log_function = log_function'
        if data_path is not None:
            class_creation_string += ', data_path = data_path'
        class_creation_string = 'class_of_script(name=script_name{:s})'.format(class_creation_string)
        # create instance
        script_instance = eval(class_creation_string)

        # copy some other properties that might be checked later for the duplicated script
        script_instance.data = deepcopy(self.data)
        script_instance.start_time = self.start_time
        script_instance.end_time = self.end_time
        script_instance.is_running = self.is_running

        return script_instance

    def _plot(self, axes_list):
        """
        plots the data only the axes objects that are provided in axes_list
        Args:
            axes_list: a list of axes objects, this should be implemented in each subscript

        Returns: None

        """
        pass

        # add following line in self._plot if you don't want plots to refresh after first plot
        # self._plot_refresh = False

    def _update_plot(self, axes_list):
        """
        updates the data in already existing plots. the axes objects are provided in axes_list
        Args:
            axes_list: a list of axes objects, this should be implemented in each subscript

        Returns: None

        """

        # default behaviour just calls the standard plot function that creates a new image everytime it is called
        # for heavier plots such as images implement a function here that updates only the date of the plot
        # but doesn't create a whole new image
        self._plot(axes_list)

    def plot(self, figure_list):
        """
        plots the data contained in self.data, which should be a dictionary or a deque of dictionaries
        for the latter use the last entry

        """
        axes_list = self.get_axes_layout(figure_list)
        if self._plot_refresh is True:
            self._plot(axes_list)
            for figure in figure_list:
                if figure.axes:
                    figure.tight_layout()
            self._plot_refresh = False
        else:
            self._update_plot(axes_list)

    def get_axes_layout(self, figure_list):
        """
        returns the axes objects the script needs to plot its data
        the default creates a single axes object on each figure
        This can/should be overwritten in a child script if more axes objects are needed
        Args:
            figure_list: a list of figure objects
        Returns:
            axes_list: a list of axes objects

        """
        axes_list = []
        if self._plot_refresh is True:
            for fig in figure_list:
                fig.clf()
                axes_list.append(fig.add_subplot(111))
                # self.log('REFRESHED')
        else:
            for fig in figure_list:
                axes_list.append(fig.axes[0])
                # self.log('NOT REFRESHED')

        return axes_list

    def plot_validate(self, figure_list):
        """
        plots the data contained in self.data, which should be a dictionary or a deque of dictionaries
        for the latter use the last entry

        """
        axes_list = self.get_axes_layout_validate(figure_list)
        self._plot_validate(axes_list)

    def _plot_validate(self, axes_list):
        pass

    def get_axes_layout_validate(self, figure_list):
        return self.get_axes_layout(figure_list)




if __name__ == '__main__':
    from src.core.read_write_functions import load_b26_file
    from src.instruments import DummyInstrument
    from src.scripts import ScriptDummyWithInstrument, ScriptDummy

    from src.core import Script

    f = 'Z:\\Lab\\Cantilever\\Measurements\\_tmp\\test.b26s'
    script, instruments = Script.load(f)

    print(script)

    print('----')
    print(instruments)

    # #
    # s, _, _ = Script.load_and_append({'s1':'ScriptDummyWithInstrument'})
    # s = s['s1']
    # print('------')
    # # s = ScriptDummyWithInstrument()
    #
    # # print(s)
    # s.update({'count': 55})
    # s.save('Z:\\Lab\\Cantilever\\Measurements\\_tmp\\test.b26s')
    # #
    # print(s)

    # s2 = ScriptDummyWithInstrument()
    # print(s2)
    # s2.load('Z:\\Lab\\Cantilever\\Measurements\\_tmp\\test.b26s')
    #
    # # print(s)
    # print('----')
    # print(s2)
